<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>never give up  gogogo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="浏览器的组成1.人机交互部分 UI2.网络请求(socket)3.js引擎(解析js)4.渲染引擎5.数据存储 渲染引擎工作原理 构建dom树 构建渲染树,剔除不显示的标签 渲染树布局,layout 绘制渲染树,加载出页面  浏览器访问网站的全过程 浏览器地址栏构建域名地址 浏览器构建请求报文 dns解析,把域名转换成ip地址 浏览器地址栏发出请求报文 服务器接收request,并解析  服务器构">
<meta property="og:type" content="article">
<meta property="og:title" content="never give up  gogogo">
<meta property="og:url" content="http://yoursite.com/2017/07/30/01/index.html">
<meta property="og:site_name" content="never give up  gogogo">
<meta property="og:description" content="浏览器的组成1.人机交互部分 UI2.网络请求(socket)3.js引擎(解析js)4.渲染引擎5.数据存储 渲染引擎工作原理 构建dom树 构建渲染树,剔除不显示的标签 渲染树布局,layout 绘制渲染树,加载出页面  浏览器访问网站的全过程 浏览器地址栏构建域名地址 浏览器构建请求报文 dns解析,把域名转换成ip地址 浏览器地址栏发出请求报文 服务器接收request,并解析  服务器构">
<meta property="og:updated_time" content="2017-07-17T14:14:16.882Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="never give up  gogogo">
<meta name="twitter:description" content="浏览器的组成1.人机交互部分 UI2.网络请求(socket)3.js引擎(解析js)4.渲染引擎5.数据存储 渲染引擎工作原理 构建dom树 构建渲染树,剔除不显示的标签 渲染树布局,layout 绘制渲染树,加载出页面  浏览器访问网站的全过程 浏览器地址栏构建域名地址 浏览器构建请求报文 dns解析,把域名转换成ip地址 浏览器地址栏发出请求报文 服务器接收request,并解析  服务器构">
  
    <link rel="alternate" href="/atom.xml" title="never give up  gogogo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">never give up  gogogo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/30/01/" class="article-date">
  <time datetime="2017-07-30T13:43:58.823Z" itemprop="datePublished">2017-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><p>1.人机交互部分 UI<br>2.网络请求(socket)<br>3.js引擎(解析js)<br>4.渲染引擎<br>5.数据存储</p>
<h2 id="渲染引擎工作原理"><a href="#渲染引擎工作原理" class="headerlink" title="渲染引擎工作原理"></a>渲染引擎工作原理</h2><ol>
<li>构建dom树</li>
<li>构建渲染树,剔除不显示的标签</li>
<li>渲染树布局,layout</li>
<li>绘制渲染树,加载出页面</li>
</ol>
<h2 id="浏览器访问网站的全过程"><a href="#浏览器访问网站的全过程" class="headerlink" title="浏览器访问网站的全过程"></a>浏览器访问网站的全过程</h2><ol>
<li>浏览器地址栏构建域名地址</li>
<li>浏览器构建请求报文</li>
<li>dns解析,把域名转换成ip地址</li>
<li>浏览器地址栏发出请求报文</li>
<li>服务器接收request,并解析 </li>
<li>服务器构建响应报文</li>
<li>服务器发送响应报文</li>
<li>浏览器接收响应报文,并解析</li>
<li>浏览器渲染页面,遇到别的资源继续发送请求</li>
<li>页面解析完成,展示页面</li>
</ol>
<h3 id="建立tcp3次握手-是建立互信机制-为了网络安全"><a href="#建立tcp3次握手-是建立互信机制-为了网络安全" class="headerlink" title="建立tcp3次握手   是建立互信机制,为了网络安全"></a>建立tcp3次握手   是建立互信机制,为了网络安全</h3><h2 id="web开发的本质"><a href="#web开发的本质" class="headerlink" title="web开发的本质"></a>web开发的本质</h2><ol>
<li>请求 客户端发送请求</li>
<li>处理 服务端处理请求</li>
<li>响应 服务端处理结果响应给客户端</li>
</ol>
<h2 id="关于C-S-和-B-S的优缺点"><a href="#关于C-S-和-B-S的优缺点" class="headerlink" title="关于C/S 和 B/S的优缺点"></a>关于C/S 和 B/S的优缺点</h2><p>cs是客户端和服务端   优点可以呈现效果比较酷炫的效果,等<br>缺点  更新要同时更新两端,工作量比较大</p>
<p>bs    服务端更新就可以了,所有效果呈现在网页上<br>        完全依赖网页,酷炫的效果  达不到</p>
<h2 id="node-js-是开发平台"><a href="#node-js-是开发平台" class="headerlink" title="node.js  是开发平台"></a>node.js  是开发平台</h2><h2 id="node的特点-优势"><a href="#node的特点-优势" class="headerlink" title="node的特点 优势"></a>node的特点 优势</h2><ol>
<li>事件驱动</li>
<li>非阻塞I/O (异步的I/O)</li>
<li>单线程</li>
<li>非常适合用作依赖其他I/O资源的中间层服务(接收到请求风发给其他服务器处理,充当传送的角色,为分布式做中转)</li>
<li>有强大的npm支持</li>
<li>可以编写发送请求的程序和处理请求的程序</li>
</ol>
<h2 id="动态网页和静态网页的区别"><a href="#动态网页和静态网页的区别" class="headerlink" title="动态网页和静态网页的区别"></a>动态网页和静态网页的区别</h2><p>静态网页  是直接在浏览器端渲染出来的,没有交互的,不依赖后台数据的<br>动态网页  是在服务器端先运行,之后发送到浏览器端的</p>
<h2 id="REPL介绍"><a href="#REPL介绍" class="headerlink" title="REPL介绍"></a>REPL介绍</h2><p>  (交互式解析器)</p>
<h2 id="node端js"><a href="#node端js" class="headerlink" title="node端js"></a>node端js</h2><p>console.log 和process.stdout.write()<br>前者输出后自带换行,后者输出后不带换行   要换行需要用’\n’转义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加载模块  </span></div><div class="line">	<span class="keyword">var</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>);</div><div class="line"><span class="comment">//写文件</span></div><div class="line">fs.writeFile(file,data[,option],callback);</div><div class="line"><span class="comment">//参数1: 要写入的文件的路径</span></div><div class="line"><span class="comment">//参数2: 要写入的数据</span></div><div class="line"><span class="comment">//参数3: 编码格式(可不写)</span></div><div class="line"><span class="comment">//参数4: 回调函数</span></div><div class="line"></div><div class="line"><span class="comment">//注意:</span></div><div class="line">	* 该操作采用异步执行</div><div class="line">	* 如果文件已经存在,则替换掉</div><div class="line">	* 默认的文件编码格式为utf8</div><div class="line">	* 回调函数有<span class="number">1</span>个参数:err   出错了err!=<span class="literal">null</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//读文件</span></div><div class="line">	fs.readFile(file[,options],callback)</div><div class="line"><span class="comment">// 参数1: 读取文件的路径</span></div><div class="line"><span class="comment">// 参数2: 编码格式(utf8  目前为止是这样)</span></div><div class="line"><span class="comment">// 参数3: 回调(两个参数 err和data)</span></div><div class="line">	</div><div class="line">如果读取文件的时候没有指定编码,那么返回的将是原生的二进制数据,</div><div class="line">如果指定了编码,那么会根据指定的编码返回对应的字符串数据</div><div class="line"></div><div class="line">文件操作中的<span class="string">'./'</span></div><div class="line">表示当前路径相对的是执行node命令的路径而不是当前被执行的js文件的实际路径</div><div class="line"><span class="string">`__dirname`</span> 才永远表示当前被执行的js文件的实际路径</div><div class="line"><span class="string">`/`</span>表示根目录,读取文件或写入文件的时候写<span class="string">`/`</span></div></pre></td></tr></table></figure>
<pre><code>1. 异步操作无法通过try-catch来捕获异常,要判断error来判断是否出错
2. 同步操作是可以通过try-catch 来捕获异常的
3. 不要使用fs.exists(path,callback)来判断文件是否存在,直接判断error即可
4. 文件操作时的路径问题
    - 在读写文件的时候&apos;./&apos;
    表示当前执行的node命令的那个路径,不是被执行的JS文件的路径
    - __dirname 表示的永远是&apos;当前被执行的js的目录&apos;
    - __filename 表示的是&quot;被执行的js的文件名(含路径)&quot;

1. 浏览器显示的可能是乱码,所以可以通过`res.setHeader(&apos;Content-Type&apos;,&apos;text/plain&apos;;charset=utf-8)`设置浏览器显示时所使用的编码
2. Chrome 浏览器默认无法手动设置编码，需要安装&quot;Set Character Encoding&quot;扩展。
3. content-type中text/html和text/plain的区别
    一个是调用html解析器处理文件
    一个是纯文本形式
</code></pre><h3 id="通过-node-js-编写-http-服务程序-通过读取静态-HTML-文件来响应用户请求"><a href="#通过-node-js-编写-http-服务程序-通过读取静态-HTML-文件来响应用户请求" class="headerlink" title="通过 node.js 编写 http 服务程序 - 通过读取静态 HTML 文件来响应用户请求"></a>通过 node.js 编写 http 服务程序 - 通过读取静态 HTML 文件来响应用户请求</h3><pre><code>* 在页面中写相对路径&apos;./&apos;很绝对路径&apos;/&apos;的含义

网页中的 这个路径是告诉浏览器向哪个地址发起请求用的
&apos;./&apos;表示本次请求从相对当前页面的请求路径开始(即服务器返回当前页面时的请求路径)
&apos;/&apos;表示请求从跟目录开始
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">res.writeHead(<span class="number">200</span>,<span class="string">'OK'</span>,&#123;</div><div class="line">	<span class="string">'Content-Type'</span>: <span class="string">'text/html; charset=utf-8'</span></div><div class="line">	&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</div><div class="line">	<span class="comment">//mime.lookup(url), 判断用哪种text/html还是别的</span></div><div class="line"></div><div class="line">	&#125;)</div><div class="line">	readFile读取文件前无需判断文件是否已经存在,而是在读取文件的回调函数中的error错误信息来判断读取的文件是否成功以及发生的错误</div><div class="line"></div><div class="line">	<span class="comment">//err.code === 'ENOENT' 判断是否请求的文件是否不存在</span></div><div class="line">	<span class="comment">//err.code === 'EACCES' eacces判断文件是否有访问权限</span></div></pre></td></tr></table></figure>
</code></pre><h2 id="同步文件操作-和异步文件操作"><a href="#同步文件操作-和异步文件操作" class="headerlink" title="同步文件操作 和异步文件操作"></a>同步文件操作 和异步文件操作</h2><ul>
<li><code>fs.readFile(file[,options],callback)</code></li>
<li><code>fs.readFileSync(file[,option])</code></li>
</ul>
<h2 id="通过设置http-响应报文头实现弹框下载功能"><a href="#通过设置http-响应报文头实现弹框下载功能" class="headerlink" title="通过设置http 响应报文头实现弹框下载功能"></a>通过设置http 响应报文头实现弹框下载功能</h2><ol>
<li><p>设置    <code>Content-Type:application/octet-stream</code>  //流,以流的形式下载</p>
</li>
<li><p>设置<code>Content-Disposition: attachment; filename=demo.txt</code></p>
</li>
</ol>
<h2 id="request-对象-对象类型"><a href="#request-对象-对象类型" class="headerlink" title="request 对象    对象类型 "></a>request 对象    对象类型 <http.incomingmessage></http.incomingmessage></h2><pre><code>Request对象常用成员

`request.headers`
`request.rawheader`
`request.httpVersion`
`request.method`
`req.url`


response对象    对象类型 &lt;http.ServerResponse&gt;
response.writeHead(statusCode[,statusMessage][,headers])
这个方法在每次请求响应前都必须被调用(只能调用一次),并且必须在end()方法调用前调用

如果在调用writeHead() 方法之前调用了 write() 或者end()方法,系统会自动帮你调用writeHead()方法,并且会生成默认的响应头

如果通过res,setHeader()也设置了响应头,那么系统会将setHeader()设置响应头和writeHeader()设置的响应头合并,并且writeHead()的设置优先

res.write(chunk[,encoding][,callback])

参数1: 要写入的数据,可以是字符串或者二进制数据
参数2: 编码,默认是utf8,选填
参数3: 回调函数,选填


res.end([data][,encoding][,callback])
结束响应

res.end()每次响应都要调用这个方法,用来结束响应

参数1: 结束响应前要发送的数据
参数2: 编码
参数3: 回调函数

res.setHeader(name,value)
* 设置响应报文头

res.statusCode
* 设置或读取http响应码

res.statusMessage
* 设置读取http响应状态的消息

npm  是包管理工具
</code></pre><p>在项目的根目录下，执行<code>npm install 包名称</code>安装<br>通过<code>npm install 包名</code>安装的包，会自动下载到当前目录下的<code>node_modules</code>目录下，如果该目录不存在，则创建，如果已存在则直接下载进去。    </p>
<pre><code>npm的全局安装

npm install 包名 -g   
npm全局安装指的是把包安装成了一个命令行工具

install 安装包
uninstall 卸载包  npm uninstall 包名
version  npm version 或者 npm -v
</code></pre><p>npm init 创建一个package.json  文件  一般用npm init -y</p>
<p>Module模块 和package 包的区别</p>
<p>模块可以是任何一个文件或目录(目录下可以有很多文件),只要能被node.js通过require()即可.</p>
<p>包是一个文件或者目录(目录下可以有多个文件),必须有一个package.json  文件来描述,就可以是一个包</p>
<p>package.json</p>
<p>是一个包说明文件(项目描述文件),用来管理组织一个包(一个项目)<br>是一个json格式的文件<br>位于当前项目的根目录下</p>
<h2 id="package-json-文件中常见的项有哪些？"><a href="#package-json-文件中常见的项有哪些？" class="headerlink" title="package.json 文件中常见的项有哪些？"></a>package.json 文件中常见的项有哪些？</h2><ul>
<li>name<ul>
<li>包的名字</li>
</ul>
</li>
<li>version<ul>
<li>包的版本</li>
</ul>
</li>
<li>description<ul>
<li>包描述</li>
</ul>
</li>
<li>author<ul>
<li>包的作者</li>
</ul>
</li>
<li>main<ul>
<li>包的入口文件,从main字段这里指定的那个js文件开始执行</li>
</ul>
</li>
<li>dependencies<ul>
<li>当前包依赖的其他包</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/30/01/" data-id="cj5qs1mx00000pouxp4yqfryb" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/07/30/02.javascript高级01/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nieuwer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/07/30/never-give-up/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">never give up</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/30/关于JSON对象/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/30/05.javascript高级04/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/30/04.javascript高级03/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/30/03.javascript高级02/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/30/02.javascript高级01/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>